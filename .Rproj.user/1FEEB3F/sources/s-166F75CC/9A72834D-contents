#skills_w7
#Population: Who is the population of N observations of interest?
#Obama poll: N=? young Americans aged 18-29

#Population parameter: What is the population parameter?
#Obama poll: The true population proportion p of young Americans who approve of Obama’s job performance.

#Census: What would a census be in this case?
#Obama poll: Locating all N=? young Americans (which is in the millions) and asking them if they approve of Obama’s job performance. This would be quite expensive to do!
    
#Sampling: How do you acquire the sample of size n observations?
#Obama poll: One way would be to get phone records from a database and pick out n phone numbers. In the case of the above poll, the sample was of size n=2089 young adults.

#Point estimates/sample statistics: What is the summary statistic based on the sample of size n that estimates the unknown population parameter?
#Key: The sample proportion red pˆ of young Americans in the sample of size n=2089 that approve of Obama’s job performance. In this study’s case, pˆ=0.41 which is the quoted 41% figure in the article.

#Representative sampling: Is the sample procedure representative? In other words, to the resulting samples “look like” the population?
#Obama poll: Does our sample of n=2089 young Americans “look like” the population of all young Americans aged 18-29?
    
#Generalizability: Are the samples generalizable to the greater population?
#Obama poll: Is pˆ=0.41 a “good guess” of p? In other words, can we confidently say that 41% of all young Americans approve of Obama.
#Bias: Is the sampling procedure unbiased? In other words, do all observations have an equal chance of being included in the sample?
#Obama poll: Did all young Americans have an equal chance at being represented in this poll? For example, if this was conducted using a database of only mobile phone numbers, would people without mobile phones be included? What about if this were an internet poll on a certain news website? Would non-readers of this this website be included?
#Random sampling: Was the sampling random?
#Obama poll: Random sampling is a necessary assumption for all of the above to work. Most articles reporting on polls take this assumption as granted. In our Obama poll, you’d have to ask the group that conducted the poll: The Harvard University Institute of Politics.

#现在您已经熟悉 RMarkdown，我们鼓励您将本教程中的工作整理到 RMarkdown 文件中。出于这个原因，这些教程不再包含“代码块”，您可以在其中运行自己的 R 代码。改用.Rmd文件。
#创建一个.Rmd文件以将以下包加载到 R 中
library(dplyr)
library(ggplot2)
library(janitor)
library(moderndive)
library(infer)

#Bootstrapping
View(orig_pennies_sample)

#探索性数据分析
ggplot(orig_pennies_sample,aes(x=age_in_2011))+
  geom_histogram(bins=10,col="white")

#我们在这里看到一个大致对称的分布，其中有不少接近 20 岁的值，只有少数大于 40 岁或小于 5 岁。如果orig_pennies_sample是来自总体的代表性样本，我们预计 2011 年收集的所有美国便士的年龄将具有相似的形状、相似的分布以及与均值等集中趋势的相似度量。

#那么这个样本的平均值在哪里呢？这一点将被称为我们的点估计，并为我们提供一个单一的数字，可以作为对真实人口平均年龄的猜测。回想一下如何使用dplyr包找到它

x_bar=orig_pennies_sample%>%
  summarize(stat=mean(age_in_2011))
x_bar
#我们已将此样本均值表示为X¯，这是表示样本均值的标准符号。因此，我们的点估计是X¯= 25.1. 请注意，这只是一个样本，仅提供一个样本均值来估计总体均值。要构建置信区间（并为此进行任何类型的统计推断），我们需要了解该样本均值的抽样分布，即如果从同一总体中抽取许多相同大小的样本，其值将如何变化.

#自举过程允许我们使用单个样本来生成许多不同的样本，这些样本将作为我们使用创建的自举分布来近似采样分布的方式。我们将使用单个样本 ( ) 来“通过我们的引导程序自力更生”（正如英语中的谚语，请参阅此处）来orig_pennies_sample了解样本均值的抽样分布。

#引导过程
#引导使用采样的过程与更换，从我们的原始样本来创建新的bootstrap样本中的相同大小作为我们的原始样本。我们可以使用包中的rep_sample_n()函数infer来探索这样的引导程序示例的样子。请记住，我们在此处从原始样本中随机抽样并进行替换，并且我们始终使用与原始样本大小相同的样本大小作为引导样本 ( orig_pennies_sample)。

bootstrap_sample1=orig_pennies_sample%>%
  rep_sample_n(size=40,replace=T,reps=1)
bootstrap_sample1

#让我们想象一下这个新的引导程序示例是什么样的：
ggplot(bootstrap_sample1, aes(x = age_in_2011)) +
  geom_histogram(bins = 10, color = "white")

#我们现在有另一个样本，我们可以假设来自感兴趣的人群。我们可以类似地计算这个 bootstrap 样本的样本均值，称为bootstrap statistic。

bootstrap_sample1 %>% 
  summarize(stat = mean(age_in_2011))

#放回抽样的过程是我们如何使用原始样本来猜测总体中的其他值可能是什么。有时在这些 bootstrap 样本中，我们会从原始样本中选择很多较大的值，有时我们会选择很多较小的值，最常见的是我们会选择靠近样本中心的值。让我们探索age_in_2011六个不同引导程序样本的值的分布情况，以进一步了解这种可变性。
six_bootstrap_samples <- orig_pennies_sample %>% 
  rep_sample_n(size = 40, replace = TRUE, reps = 6)

ggplot(six_bootstrap_samples, aes(x = age_in_2011)) +
  geom_histogram(bins = 10, color = "white") +
  facet_wrap(~ replicate)

#我们还可以使用dplyr语法查看六种不同的方法：
View(six_bootstrap_samples)

six_bootstrap_samples %>% 
  group_by(replicate) %>% 
  summarize(stat = mean(age_in_2011))

#我们可以这样做 1000 次，而不是这样做 6 次，然后查看stat所有 1000 个replicates的分布。这为inferR 包奠定了基础（请参阅此处的文档或 DA Moodle 页面上的“备忘单”），帮助用户使用类似于您在dplyr. 在下一节中，我们将infer使用此orig_pennies_sample示例逐步介绍为置信区间设置每个动词，同时还将在一般框架中解释动词的用途。

#用于统计推断的infer包
#该infer软件包充分利用了tidyverse“管道”%>%来创建用于统计推理的管道。该软件包的目标是为其用户提供一种使用代码作为指导来解释置信区间和假设检验的计算过程的方法。动词在此处按顺序构建，因此您需要先开始，specify()然后根据需要继续完成其他动词。

#该specify()函数主要用于选择哪些变量将成为统计推断的重点。另外，这里还设置了哪个变量作为变量，哪个变量explanatory作为response变量。对于比例问题（即表 1 中的场景 1 和 3），我们还指定了我们正在计算的不同级别中的哪个比例（例如“女性”、“批准奥巴马的工作表现”等）。
#为了开始为 2011 年美国便士的人口平均年龄创建置信区间，我们首先使用我们要使用specify()的orig_pennies_sample数据中的哪个变量进行选择。这可以通过以下两种方式之一完成：

#使用response参数：
orig_pennies_sample %>% 
  specify(response = age_in_2011)
#使用formula符号：
orig_pennies_sample %>% 
  specify(formula = age_in_2011 ~ NULL)

#specify()在我们的推理分析中加入我们想要的变量之后，我们接下来将其输入到generate()动词中。该generate()动词的主要论点是reps，它是用来给一个想多少不同的重复执行。这里的另一个参数是type，它由传入的变量类型自动确定specify()。我们也可以明确地将其设置type为type = "bootstrap". 请务必查看?generate此处的选项并使用?运算符更好地理解其他动词。

#让我们generate()1000 个引导程序样本：
thousand_bootstrap_samples <- orig_pennies_sample %>% 
  specify(response = age_in_2011) %>% 
  generate(reps = 1000)

#我们可以使用该dplyr count()函数来帮助我们了解thousand_bootstrap_samples数据框的样子：
thousand_bootstrap_samples %>% count(replicate)

#请注意，replicate此处每个条目都有 40 个条目。现在我们有 1000 个不同的 bootstrap 样本，下一步是calculate对每个样本进行 bootstrap 统计。

#在generate()输入了许多不同的样本之后，接下来我们想将这些样本压缩为每个replicated 样本的单个统计量。如图所示，该calculate()功能在这里很有用。

#正如我们在本章开头所做的那样，我们现在要计算age_in_2011每个引导样本的均值。为此，我们使用stat参数并将其设置为"mean"下面。这里的stat论证有多种不同的选择，我们将在其余章节中看到更多的例子。

bootstrap_distribution <- orig_pennies_sample %>% 
  specify(response = age_in_2011) %>% 
  generate(reps = 1000) %>% 
  calculate(stat = "mean")
bootstrap_distribution

#我们看到结果数据有 1000 行和 2 列，对应于 1000 次重复和每个引导样本的平均值。

#观察统计/点估计计算
#正如在 中group_by() %>% summarize()生成有用的工作流一样dplyr，我们还可以使用它specify() %>% calculate()来计算原始样本数据的汇总度量。在置信区间计算和假设检验中，确定原始数据中相应的统计量通常很有帮助。对于我们关于便士年龄的示例，我们在上面计算了x_bar使用summarize()动词 in的值dplyr：
orig_pennies_sample %>% 
  summarize(stat = mean(age_in_2011))

#This shortcut will be particularly useful when the calculation of the observed statistic is tricky to do using dplyr alone. This is particularly the case when working with more than one variable.

#可视化结果
#该visualize()动词提供了一种将自举分布视为stat变量值的直方图的简单方法。它还有许多其他参数可以使用，包括与置信区间值对应的直方图值的阴影。

bootstrap_distribution%>%visualize()

#构建置信区间
#置信区间在科学和任何使用数据的领域中都发挥着重要作用。您可以将置信区间视为在钓鱼时扮演网的角色。我们可以使用网来尝试为鱼提供一系列可能的位置（使用范围基于我们的样本统计数据的可能值，以对参数的位置做出合理的猜测）。

#自举过程提供自举统计，其自举分布的中心位于（或非常接近）原始样本的均值。这可以通过为观察到的统计obs_stat参数提供点估计值来看出x_bar。

bootstrap_distribution %>% visualize(obs_stat = x_bar)

#我们还可以计算均值的 bootstrap 分布的均值，以查看它与 的比较x_bar
bootstrap_distribution %>% 
  summarize(mean_of_means = mean(stat))

#正如我们在上一节中提到的，bootstrap 分布提供了对样本均值的抽样分布的估计，即来自相同大小的不同样本的不同样本均值的变异性可能看起来像，仅使用原始样本作为我们的指导. 我们可以通过两种不同的方式以 95% 置信区间的形式量化这种可变性。

#1.百分位法
#计算 2011 年未知硬币平均年龄的一系列合理值的一种方法是使用中间 95%bootstrap_distribution来确定我们的端点。因此，我们的终点位于第 2.5个和第97.5个百分位数。这可以通过infer使用该get_ci()函数来完成。（您也可以在此处使用conf_int()orget_confidence_interval()函数，因为它们是工作方式完全相同的别名。）
bootstrap_distribution%>%
  get_ci(level=0.95,type="percentile")

percentile_ci <- bootstrap_distribution %>% 
  get_ci()
percentile_ci

#使用百分位数方法，我们对 2011 年流通的美国便士平均年龄的合理值范围是 21 到 29.4 年。我们可以使用该visualize()函数使用endpoints和direction参数来查看它，设置direction为"between"（在值之间）和endpoints使用 name 存储的那些percentile_ci。

bootstrap_distribution %>% 
  visualize(endpoints = percentile_ci, direction = "between")

#Standard Deviation
#当level提供level = 0.95为默认值时，它会自动计算。（标准正态分布中 95% 的值落在均值的 1.96 个标准差内，因此multiplier = 1.96对应于level = 0.95，例如。）如上所述，该公式假设自举分布是对称的和钟形的。自举分布通常就是这种情况，尤其是那些样本的原始分布没有高度偏斜的分布。

#请注意，point_estimate必须为标准误差置信区间提供置信区间的中心 (the )。
standard_error_ci=bootstrap_distribution%>%
  get_ci(type="se",point_estimate=x_bar)
standard_error_ci

#解释置信区间
#回想一下，我们产生的置信区间是基于使用单个样本的引导orig_pennies_sample。我们一直声称这是从所有在2011年流通中的硬币的样本，但我们现在可以透露，它实际上是从存储便士较大数量的样本pennies在moderndive包中。所述pennies数据帧包含800行数据和关于相同的变量的两列orig_pennies_sample。重要的是要强调这是非常人为的，即我们通常永远无法访问有关我们的样本所来自的更大组的所有信息，但我们在这里设置数据以说明置信区间的属性解释置信区间的目的。

#所以让我们假设这pennies是我们感兴趣的群体（即具有N= 800单位）。因此，我们可以计算出 2011 年人口平均使用便士的年龄，用希腊字母表示μ通过计算平均值的age_in_2011用于pennies数据帧。

pennies_mu <- pennies %>% 
  summarize(overall_mean = mean(age_in_2011)) %>% 
  pull()  #Use this function to extract the single value from the data frame
pennies_mu

#如果我们有一个大小为 40 的不同样本并使用相同的方法构建置信区间，我们是否能保证它包含总体参数值 μ还有？让我们试试看：
pennies_sample2 <- pennies %>% 
  sample_n(size = 40)
#注意这里包中sample_n()函数的使用dplyr。这与rep_sample_n(reps = 1)省略额外replicate列的作用相同。

#我们接下来创建一个infer管道来生成基于百分位数的 95% 置信区间μ：

percentile_ci2 <- pennies_sample2 %>% 
  specify(formula = age_in_2011 ~ NULL) %>% 
  generate(reps = 1000) %>% 
  calculate(stat = "mean") %>% 
  get_ci()
percentile_ci2

#这个新的置信区间还包含 μ. 让我们通过重复此过程 100 次来进一步研究，以从 100 个不同的 样本中获得 100 个不同的置信区间pennies。与原始样本一样，每个样本的大小为 40。我们将把每个置信区间绘制为水平线。我们还将显示一条与已知人口值 21.1525 年相对应的线。

#基于样本大小的 100 个置信区间 n = 40, 其中 96 个捕获了总体平均值 μ = 21.15，而其中 4 个没有包含它。如果我们用更多样本重复这个建立置信区间的过程，我们预计其中 95% 包含总体均值。换句话说，我们用来生成置信区间的过程是“95% 可靠的”，因为如果重复该过程，我们可以预期它在 95% 的时间内包含真实的总体参数。

#为了进一步强调这一点，让我们使用 90% 置信区间来执行类似的过程。这次我们将使用标准误差法而不是百分位法来计算置信区间。

#对更多样本重复此过程将导致我们越来越接近 90% 的置信区间，包括真实值。在将置信区间解释为“95% 置信度”或“90% 置信度”时，通常会说指定的置信区间包含真实值。我们将在本章的其余部分使用这种“自信”的语言，但请记住，这是关于如果我们从同一个总体中一次又一次地抽样（我们在实践中不会这样做），我们预期会发生什么的理论陈述， 当然）。

#回到我们的便士例子
#在详细说明置信区间中的水平对应的内容之后，让我们通过对我们在上一节中找到的原始置信区间结果进行解释来得出结论。

#解释：

#我们有 95% 的信心，从 21 年到 29.4 年的值范围包含 2011 年流通中便士的真实平均年龄。

#如果收集了许多不同的样本（不仅仅是我们使用的样本）并创建了置信区间，则此置信水平基于基于百分位数的方法，包括 95% 的真实平均值。

#COMPARE TWO 
#让我们从一个例子开始。如果你看到别人打哈欠，你更有可能打哈欠吗？在电视节目流言终结者的一集中，他们验证了打哈欠会传染的神话。
#50 名认为自己被考虑参加节目的成年人接受了节目招聘人员（“同盟”）的采访，他们要么打哈欠，要么不打哈欠。然后，参与者独自坐在一辆大货车里，并被要求等待。在面包车里，流言终结者通过隐藏的摄像头观看不知情的参与者是否打哈欠。包含结果的数据框mythbusters_yawn位于moderndive包中。让我们来看看。

mythbusters_yawn
mythbusters_yawn%>%
  tabyl(group,yawn)%>%
  adorn_percentages()%>%
  adorn_pct_formatting()%>%
  adorn_ns() #to show original counts

#计算点估计
#我们正在研究打哈欠与参与者是否看到有人打哈欠 ( seed) 与否 ( control) 之间的关系。
mythbusters_yawn%>%
  specify(formula = yawn~group)

#请注意，success必须在响应变量只有两个级别的情况下指定参数。
mythbusters_yawn %>% 
  specify(formula = yawn ~ group, success = "yes")

#接下来我们要计算我们样本的感兴趣的统计量。这对应于成功比例的差异。
mythbusters_yawn %>% 
  specify(formula = yawn ~ group, success = "yes") %>% 
  calculate(stat = "diff in props")

#我们在这里看到另一个错误。为了进一步检查以确保 R 确切地知道我们在追求什么，我们需要提供orderR 应该减去这些成功比例的值。由于错误消息指出，我们希望把"seed"第一后c()，然后"control"：order = c("seed", "control")。我们的点估计是这样计算的：
obs_diff <- mythbusters_yawn %>% 
  specify(formula = yawn ~ group, success = "yes") %>% 
  calculate(stat = "diff in props", order = c("seed", "control"))
obs_diff

#multi-bootstrap
#我们建立置信区间的下一步是创建统计的引导分布（成功比例的差异）。我们在pennies示例中看到了它如何在计算 bootstrap 均值时使用单个变量，但我们还没有使用涉及多个变量的 bootstrapping，即比较两组。在infer包中，使用多个变量进行引导意味着每一行都可能被重新采样。让我们通过查看 的前几行来对此进行调查mythbusters_yawn：

head(mythbusters_yawn)

set.seed(2019)

head(mythbusters_yawn) %>% 
  sample_n(size = 6, replace = TRUE)
#我们可以看到，在这个从 的前六行生成的引导样本中mythbusters_yawn，我们有一些重复的行。当我们执行下面的generate()步骤时infer也是如此。
bootstrap_distribution <- mythbusters_yawn %>% 
  specify(formula = yawn ~ group, success = "yes") %>% 
  generate(reps = 1000) %>% 
  calculate(stat = "diff in props", order = c("seed", "control"))

bootstrap_distribution %>% 
  visualize(bins = 20)

bootstrap_distribution %>% 
  get_ci(type = "percentile", level = 0.95)

#因此，我们不确定哪个比例更大。一些引导统计显示没有种子的比例更高，而其他的则显示有种子的比例更高。如果置信区间完全高于零，我们将相对确定（大约“95% 的置信度”）种子组比对照组打哈欠的比例更高。

#请注意，这一切都与order在calculate()函数中表示参数的重要性有关。由于我们指定"seed"然后"control"正值用于统计对应于"seed"比例为高，而负值对应于"control"基团为高。

#因此，我们通过这个置信区间有证据表明，流言终结者的结论表明“打哈欠是会传染的”被“确认”在统计上是不正确的。

#Further Tasks
#You are encouraged to complete the following tasks by using RMarkdown to produce a single document
#which summarises all your work, i.e. the original questions, your R code, your comments and reflections, etc.

#Question 1
#In the last section, we constructed a confidence interval for the difference in the proportion of people who
#yawned between the “seeded” group and the “control” group (Scenario 3).

#在上一节中，我们为“种子”组和“对照组”之间打哈欠的人数比例差异构建了置信区间（情景 3）。

#根据我们在“构建置信区间”部分（场景2）中如何构建便士年龄的置信区间，通过修改上一节中的代码，使用mythbusters_yawn数据构建打哈欠人口比例的置信区间当他们看到别人打哈欠时（场景 1）。这是否与没有看到其他人打哈欠时打哈欠的人比例的置信区间重叠（又是情景 1！）？您在此处的发现与上一节的发现一致吗？

#We start by focusing on the group that saw someone yawn, i.e. group == "seed":
bootstrap_distribution=mythbusters_yawn%>%
  filter(group=="seed")%>%
  specify(formula = yawn~NULL,success="yes")%>%
  generate(rep=1000)%>%
  calculate(stat="prop")
bootstrap_distribution%>%visualize(bins=20)

bootstrap_distribution %>%
  get_ci(type = "percentile", level = 0.95)

#The confidence interval shown here is (0.15, 0.47). The range of plausible values for the proportion of people
#that yawned with after seeing someone yawn is therefore between 0.15 and 0.47.
#We now repeat the exercise but for the group that didn’t see someone yawn, i.e. group == "control"
bootstrap_distribution <- mythbusters_yawn %>%
  filter(group=="control") %>%
  specify(formula = yawn ~ NULL, success = "yes") %>%
  generate(reps = 1000) %>%
  calculate(stat = "prop")
bootstrap_distribution %>% visualize(bins = 20)

bootstrap_distribution %>%
  get_ci(type = "percentile", level = 0.95)

#that yawned without seeing someone yawn is therefore between 0.06 and 0.5.
#Comparing the two CIs for the proportion of those that saw someone yawn (0.15, 0.47) and those that didn’t
#(0.06, 0.5), we note that these two CIs overlap, which is consistent with the findings from the CI for the
#difference in the two proptions (-0.23, 0.31) in the last section, i.e. since they do overlap its plausible that
#they could each take the same value and therefore its plausible that their difference is zero, which is
#exactly what the CI for the difference in proportions tells us.

#that yawned without seeing someone yawn is therefore between 0.06 and 0.5.

#Comparing the two CIs for the proportion of those that saw someone yawn (0.15, 0.47) and those that didn’t
#(0.06, 0.5), we note that these two CIs overlap, which is consistent with the findings from the CI for the
#difference in the two proptions (-0.23, 0.31) in the last section, i.e. since they do overlap its plausible that
#they could each take the same value and therefore its plausible that their difference is zero, which is
#exactly what the CI for the difference in proportions tells us.

setwd("/Users/kurisuuu/Documents/glasgow_stats_2021/semester\ 2/das/das_week4/Practice\ Class\ Test\ Files-20210621")
cats <- read.csv("cats.csv")
glimpse(cats)

#Solution 2.a.
#a. Construct a bootstrap confidence intervals for the avearge heart weight of female and male
#cats separately? Interpret your results.

bootstrap_distribution <- cats %>%
  filter(Sex == "F") %>%
  specify(response = Hwt) %>%
  generate(reps = 1000) %>%
  calculate(stat = "mean")
#bootstrap_distribution %>% visualize()
percentile_ci <- bootstrap_distribution %>%
  get_ci()
percentile_ci

bootstrap_distribution <- cats %>%
  filter(Sex == "M") %>%
  specify(response = Hwt) %>%
  generate(reps = 1000) %>%
  calculate(stat = "mean")
#bootstrap_distribution %>% visualize()
percentile_ci <- bootstrap_distribution %>%
  get_ci()
#percentile_ci

#Solution 2.b.
#b. Construct a bootstrap confidence interval for the difference in the avearge heart weights of
#female and male cats. Interpret your result.
bootstrap_distribution <- cats %>%
  specify(Hwt~Sex)%>%
  generate(reps=1000)%>%
  calculate(stat="diff in means",order=c("F","M"))
percentile_ci <- bootstrap_distribution %>%
  get_ci()
percentile_ci

#Using the percentile method, our range of plausible values for the difference in the mean heart weight between
#female and male adult cats is -2.73 grams to -1.48 grams. That is to say that on average female adult cats’
#hearts weigh between 1.48 and 2.73 grams less than adult male cats’ hearts. (Note: the fact that the
#individual CIs in part a. didn’t overlap told us that zero wouldn’t be in the interval for the difference in the

#c. Repeat a. and b. for the body weight of cats.
cats <- read.csv("cats.csv")
bootstrap_distribution <- cats %>%
  filter(Sex == "F") %>%
  specify(response = Bwt) %>%
  generate(reps = 1000) %>%
  calculate(stat = "mean")
percentile_ci <- bootstrap_distribution %>%
  get_ci()

bootstrap_distribution <- cats %>%
  filter(Sex == "M") %>%
  specify(response = Bwt) %>%
  generate(reps = 1000) %>%
  calculate(stat = "mean")
percentile_ci <- bootstrap_distribution %>%
  get_ci()

bootstrap_distribution <- cats %>%
  specify(Bwt~Sex) %>%
  generate(reps = 1000) %>%
  calculate(stat = "diff in means", order = c("F", "M"))
percentile_ci <- bootstrap_distribution %>%
  get_ci()

#Using the percentile method, our range of plausible values for the difference in the mean body weight between
#female and male adult cats is -0.65 kilograms to -0.42 kilograms. That is to say that on average female adult
#cats’ bodies weigh between 0.42 and 0.65 kilograms less than adult male cats’ bodies. (Note: the fact that
                                                                                       the individual CIs in part a. didn’t overlap told us that zero wouldn’t be in the interval for the difference in
                                                                                       the population means)

                                                                             
                                                                             
                                                                             
                                                                             